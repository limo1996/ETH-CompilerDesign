package cd.backend.codegen;

import java.io.Writer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;

import cd.Config;
import cd.Main;
import cd.backend.ExitCode;
import cd.backend.codegen.RegisterManager.Register;
import cd.ir.Ast;
import cd.ir.Ast.ClassDecl;
import cd.ir.Ast.Var;
import cd.ir.AstRewriteVisitor;
import cd.ir.AstVisitor;
import cd.ir.Symbol;
import cd.ir.Symbol.ClassSymbol;

public class AstCodeGenerator {

	protected RegsNeededVisitor rnv;
	
	protected ExprGenerator eg;
	protected StmtGenerator sg;
	
	protected final Main main;
	
	protected final AssemblyEmitter emit;
	protected final RegisterManager rm = new RegisterManager();

	AstCodeGenerator(Main main, Writer out) {
		
		initMethodData();
		
		this.emit = new AssemblyEmitter(out);
		this.main = main;
		this.rnv = new RegsNeededVisitor();

		this.eg = new ExprGenerator(this);
		this.sg = new StmtGenerator(this);
	}

	protected void debug(String format, Object... args) {
		this.main.debug(format, args);
	}

	public static AstCodeGenerator createCodeGenerator(Main main, Writer out) {
		return new AstCodeGenerator(main, out);
	}
	
	protected static final String VAR_PREFIX = "var_";
	
	/**
	 * Main method. Causes us to emit x86 assembly corresponding to {@code ast}
	 * into {@code file}. Throws a {@link RuntimeException} should any I/O error
	 * occur.
	 * 
	 * <p>
	 * The generated file will be divided into two sections:
	 * <ol>
	 * <li>Prologue: Generated by {@link #emitPrefix()}. This contains any
	 * introductory declarations and the like.
	 * <li>Body: Generated by {@link ExprGenerator}. This contains the main
	 * method definitions.
	 * </ol>
	 */
	public void go(List<? extends ClassDecl> astRoots) {
		// convert vars to fields if they are
		for(ClassDecl ast: astRoots) {
			ast.accept(new AstRewriteVisitor<ClassDecl>() {
				@Override
				public Ast classDecl(ClassDecl ast, ClassDecl arg) {
					return visitChildren(ast, ast);
				}

				@Override
				public Ast var(Var ast, ClassDecl arg) {
					switch (ast.sym.kind) {
						case PARAM :
						case LOCAL :
							return ast;
						case FIELD :
							Ast.ThisRef thisRef = new Ast.ThisRef();
							thisRef.type = arg.sym;
							Ast.Field f = new Ast.Field(thisRef, ast.name);
							f.type = ast.type;
							f.sym = ast.sym;
							return f;
					}
					throw new RuntimeException("Unknown kind of var");
				}
			}, null);
		}
		// emit VTables
		emitVTables(astRoots);
		// find main and emit prologue
		for(ClassDecl ast : astRoots) {
			if(ast.name.equals("Main")) {
				emitPrologue(ast);
				break;
			}
		}
		// emit code for classes
		for (ClassDecl ast : astRoots) {
			sg.classDecl(ast, new Context(ast));
		}
	}
	
	private void emitVTables(List<? extends ClassDecl> astRoots) {
		// keep track of Classes that were processed 
		Set<ClassSymbol> processed = new HashSet<ClassSymbol>();
		//processed.add(ClassSymbol.objectType);
		// start region
		emit.emitComment("VTables region");
		emit.emitRaw(Config.DATA_INT_SECTION);
		// for each class
		for(ClassDecl ast : astRoots) {
			// skip if already processed
			if(processed.contains(ast.sym))
				continue;
			
			Stack<ClassSymbol> toProcess = new Stack<ClassSymbol>();
			ClassSymbol curr = ast.sym;
			// traverse the inheritance tree up till we find a class that was processed
			while(!processed.contains(curr) && curr != null) {
				toProcess.push(curr);
				curr = curr.superClass;
			}
			// reverse order and process
			while(!toProcess.empty()) {
				curr = toProcess.pop();
				emitTables(curr);
				processed.add(curr);
			}
		}
		
		// emit vtables for arrays
		emit.emitComment("VTables for primitive arrays:");
		emit.emitLabel(BackendUtils.getVTableArrayLabel("int"));
		emit.emitConstantData(BackendUtils.getVTableLabel("Object"));
		
		emit.emitLabel(BackendUtils.getVTableArrayLabel("boolean"));
		emit.emitConstantData(BackendUtils.getVTableLabel("Object"));
	}
	
	private void emitTables(ClassSymbol sym) {
		// build OTable
		sym.o_table = new OTable(sym);
		// build VTable
		sym.v_table = new VTable(sym);
		// emit VTable
		sym.v_table.emit(emit);
		// emit Array Table
		sym.v_table.emitArray(emit);
	}
	
	private void emitPrologue(ClassDecl main) {
		// Emit some useful string constants:
		emit.emitRaw(Config.DATA_STR_SECTION);
		emit.emitLabel("STR_NL");
		emit.emitRaw(Config.DOT_STRING + " \"\\n\"");
		emit.emitLabel("STR_D");
		emit.emitRaw(Config.DOT_STRING + " \"%d\"");
		
		// Emit main
		emit.emitRaw(Config.TEXT_SECTION);
		emit.emitRaw(".globl " + Config.MAIN);
		emit.emitLabel(Config.MAIN);
		
		// emit function prologue
		emit.emit("enter", AssemblyEmitter.constant(8), AssemblyEmitter.constant(0));
		emit.emit("and", -16, Register.ESP);
		
		// EAX should not be in use!
		assert(!rm.isInUse(Register.EAX));
		Register main_ptr = rm.getRegister();
		
		List<String> args = new ArrayList<String>();
		args.add(AssemblyEmitter.constant(BackendUtils.size(main)));
		args.add(AssemblyEmitter.constant(Config.SIZEOF_PTR));
		
		// new Main()
		BackendUtils.pushArguments(emit, args, 0);
		emit.emit("call", Config.CALLOC);
		emit.emitMove(Register.EAX, main_ptr);
		BackendUtils.popArguments(emit, args, 0);
		
		// get pointer to vtable of main
		Register vtable_ptr = rm.getRegister();
		emit.emit("leal", main.sym.v_table.name(), vtable_ptr);
		emit.emitStore(vtable_ptr, 0, main_ptr);
		
		// save this on the stack, get offset of the function and call it
		emit.emitStore(main_ptr, 0, Register.ESP);
		
		emit.emitLoad(0, main_ptr, main_ptr);
		int main_offset = main.sym.v_table.methodOffset("main");
		emit.emit("addl", AssemblyEmitter.constant(main_offset), main_ptr);
		emit.emitLoad(0, main_ptr, main_ptr);
		emit.emit("call", "*" + main_ptr.repr);
		
		emit.emitStore(AssemblyEmitter.constant(ExitCode.OK.value), 0, Register.ESP);
		emit.emit("call", Config.EXIT);
		
		// release registers and return
		rm.releaseRegister(vtable_ptr);
		rm.releaseRegister(main_ptr);
	}


	protected void initMethodData() {
		rm.initRegisters();
	}


	protected void emitMethodSuffix(boolean returnNull) {
		if (returnNull)
			emit.emit("movl", "$0", Register.EAX);
		emit.emitRaw("leave");
		emit.emitRaw("ret");
	}
}